

----- Page 1 -----
Database Management System

Basics of Functional Dependencies and Normalisation for Relational

Databases


----- Page 2 -----
Outline

Q Introduction

Q Informal Design Guidelines for Relation Schemas.
Q Functional Dependencies.

Q Normal Forms based on primary keys.

Q Second and Third Normal Forms.

QO Boyce-Codd Normal Form.


----- Page 3 -----
What is Normalization ?

*Database normalization is the process of organizing data
to minimize data redundancy (data duplication), which in
turn ensures data consistency.

Problems of Data Redundancy

1. Disk Space Wastage

2. Data inconsistency

3. DML queries can become slow


----- Page 4 -----
What is Normalization ?

*Database Normalization is step by step process.

*There are five normal forms, First Normal Form (1NF)
through fifth Normal Form (SNF)

*Most databases are in third normal form (3NF).

*There are certain rules, that each normal form should
follow.


----- Page 5 -----
Redundant Information in
records and Update
Anomaly


----- Page 6 -----
Example
Student Table

ee | ache
— “ < eter]

1BM20A1002 Balaji 10 JON Aline DRIABC:
1BM20A1003, Chandan 10 20. I csE Dr POR
18M20CS001 ‘Avinash 20

18M20CS002 Dinesh 20



----- Page 7 -----
Example

Student-Department Table

1BM20A1001 ‘Avinash 10 IML Dr ABC
1BM20AI002 Balai 10 AML Dr ABC
1BM20A1003 Chandan | 10 ‘AML Dr ABC
48M20¢S001 ‘Avinash 20 ‘AML Dr POR
1BM20CS002 Dinesh 20 AML Dr POR
Update Anomalies
Insertion Deletion Modification
Anomaly Anomaly

Anomaly


----- Page 8 -----
Insertion Anomaly

‘Student-Department table

usn name
1BM20AI001 —avinash
1BM20A1002 ata
1BM20A1003 Chandan
1BM20CS001 Avinash
1BM20CS002 —inesh

Violating Primary
key constraint

dep_num Dep_name HOD

10 AIML De ABC
10 AIML De ABC
10 AIML Oe ABC
20 cse r.PaR
20 cse POR

Student-Department table

usn name
1BM2081001 gina
1BM2081002
1BM2081003——crandan
18M20€5001—inaey
1BM20CS002 ine

Say we want to introduce new
department with only department

details for which students

have not joined this
department yet ?

dep_num

10

10

10

20

20

30

Dep_name

AML

AML

AML

ose

ose

as

HOD

De aac
De aac
De aac
POR

POR

DR. LMN


----- Page 9 -----
Insertion Anomaly

Insertion Anomaly will never occur if the table design was as follows:

Student Table Department Table
usn dep_num dep_num|Dep_name| HOD
1BM20A1001 10 10 AIML Dr. ABC
1BM20A1002 10 20 CSE Dr. POR
1BM20A1003 10 30 AS DR. LMN
1BM20CS001| Avinash | _20
1BM20CS002| Dinesh 20
Student-Department table
usn name — dep_num —_—_—Dep_name HOD

teM20Al001 Avinash 10 AIML Dr. ABC

teM2oaloo2 Balaji 10 AIML Dr. ABC

18M20A1003 Chandan 10 AML Dr. ABC

tem2ocsoo1 ‘Avinash 20 CSE Dr. POR

temzocsoo2 Dinesh 20 CSE Dr. POR



----- Page 10 -----
Deletion Anomaly

Student-Department table
dep_num Dep_name

usn
1BM20A1001
1BM20A1002
1BM20A1003
1BM20CS001
1BM20CS002
1BM20AS001

name
Avinash
Balaji
Chandan
Avinash
Dinesh
Abhijit

10
10
10
20
20
30

AIML

AIML

AIML
CSE
CSE
AS

HOD
Dr. ABC
Dr. ABC
Dr. ABC
Dr. POR
Dr. POR
DR. LMN

Say we want to delete

Abhijit record from the table,
then the information related to
Aerospace department will

be lost.


----- Page 11 -----
Deletion Anomaly

Deletion Anomaly would not have occurred
if the table design was as follows. Here student and
department information is stored separately

Student Table Department Table

usn name |dep_num dep_num|Dep_name| HOD
1BM20A1001| Avinash | 10 10 AML —_| Dr. ABC
1BM20A1002| Balaji 10 20 CSE Dr. POR,
1BM20A\I003 | Chandan 10 30 AS DR. LMN

1BM20CS001| Avinash | __20
1BM20CS002| Dinesh 20
1BM20AS001| Abhijit 30



----- Page 12 -----
Modification Anomaly

Say we want to change the name of HOD for the Department AIML.
Then we have do changes to all the records referring to AIML department

Student-Department table

usn name dep_num Dep_name HOD

1BM20A1001 Avinash
1BM20A1002 Balaji

1BM20AI003 Chandan Changing name of

1BM20CS001 Avinash 20 CSE DePaR — AMLHOD should
1BM20CS002 Dinesh 20 CSE Di POR fecorde

1BM20AS001 Abhijit 30 AS DR. LMN


----- Page 13 -----
Modification Anomaly

Modification Anomaly will never occur if the
table design was as follows:

Student Table

Department Table

Changing

usn name |dep_num dep_num|Dep_name| HOD | jn, oniy

1BM20A1001| Avinash | 10 10 amt | dr.asc | one record
1BM20AI002 | Balaji 10 20 CSE Dr. PQR:
1BM20A1003 |chandan| 10 30 as [pR.LMIN
1BM20CS001 | Avinash 20
1BM20CS002/ Dinesh | _20



----- Page 14 -----
Normalization

Student-Department table

usn name dep_num Dep_name HOD
1BM20AI001 Avinash 10 AIML Dr. ABC
1BM20A1002 Balaji 10 AIML Dr. ABC
1BM20AI003 Chandan 10 AIML Dr. ABC
1BM20CS001 Avinash 20 CSE Dr. POR
1BM20CS002 Dinesh 20 CSE Dr. POR
1BM20AS001 —abhijit 30 AS DR. LMN
| Normalized Table Design
Student Table Department Table
usn name |dep_num dep_num|Dep_name| HOD
1BM20A1001) Avinash | _10 10 Amt __| Dr. aac
1BM20AI002 | Balaji 10 20 CSE Dr. PQR
1BM20A1003 |chandan| 10 30 as__|pR.LMN
1BM20CS001| Avinash | _20
1BM20CS002| Dinesh | 20



----- Page 15 -----
Informal Design
Guidelines for relation
Schemas

Four informal measures of quality for relation
schema design
1.Semantics of the Relation Attributes
2.Redundant Information in Tuples and Update Anomalies
3.Null Values in Tuples
4.Spurious Tuples


----- Page 16 -----
Guideline 1: Try to make user interpretation
easy

+ GUIDELINE 1: Informally, each tuple in a relation should represent one entity or
relationship instance. (Applies to individual relations and their attributes).

* Attributes of different entities (EMPLOYEEs, DEPARTMENTs, PROJECTS) should
not be mixed in the same relation

* Only foreign keys should be used to refer to other entities
+ Entity and relationship attributes should be kept apart as much as possible.

Design a schema that can be explained easily relation by relation.
The semantics of attributes should be easy to interpret.

*Example:

EMP(FNAME, LNAME, SSN) _EMP(FNAME,LNAME;SSN, PNO,PLOC)
WORKS_ON (SSN, PNO) Perhaps this schema has too much
PROJECT_LOC(PNO, PLOC) information to absorb per record ?


----- Page 17 -----
Guideline 2: Try to reduce Redundancy and avoid
Update Anomalies

* Information is stored redundantly
+ Wastes storage
* Causes problems with update anomalies
+ Insertion anomalies
* Deletion anomalies
* Modification anomalies

* GUIDELINE 2:
* Design a schema that does not suffer from the insertion, deletion and update
anomalies.

+ If there are any anomalies present, then note them so that applications can
be made to take them into account.


----- Page 18 -----
Guideline 3:Avoid too many NULL values

Avoid too many NULL values
*Space is wasted

*Problems occur when using aggregate functions like count or
sum

*NULLs can have different intentions
© Attribute does not apply
¢ Value unknown and will remain unknown
¢ Value unknown at present


----- Page 19 -----
Guideline 4: Spurious Tuples

*Bad designs for a relational database may result in
erroneous results for certain JOIN operations

* Split a table into smaller tables (with fewer columns in each), When
reconstructing the “original” data, should not introduce spurious
tuples

*GUIDELINE 4:
* The relations should be designed to satisfy the lossless join condition.

* No spurious tuples should be generated by doing a natural-join of any
relations.


----- Page 20 -----
What is spurious tuples ?

* A spurious tuple is, basically, a record in a database that gets created when two
tables are joined badly. In database, spurious tuples are created when two tables
are joined on attributes that are neither primary keys nor foreign keys.

+ Example, consider

CAR (DD, Make, Colo) CARI ID, Color) CCAR2 Color, Mae)
13 [Toyou [Bae 7 ive ise Toya
[56 [audi [Be icy ue Blue aoa
735 | Toyo [Rad 8 Red ed Foy

What happens when we join (or combine)
CAR1 and CAR2 ?


----- Page 21 -----
What is spurious tuples ?

A CARI (ID, Color) CAR2 (Color, Make)
+ Example, consider
rs [Blue Blue Toyota
CAR (ID, Make, Color)
12 Toyota [Blue 356 Blue Blue ‘Rudi
fa56 [Audi [Blue 739 Red Red Toyota
ee |peseee | at What happens when we join (or combine)
CARL and CAR2?
rs Blue Toyota
re) Bue [Rudi
56 Bue Toyota
56 Blue Rudi
789 Red Toyo



----- Page 22 -----
What is spurious tuples ?

«CAR (D, Make, Color)
1 Peyote [Bue
se [Aud [ie
739 Toyota [Rea

Spurious
Records

CARI (ID, Color) CAR? (Color, Make)
fia Blue [Blue Toyota
456 Blue Blue Audi
739 Red Red Toyota

What happens when we join CAR1 and CAR2 ?



----- Page 23 -----
Summarizing

Informal Design Guidelines for relation Schemas

GUIDELINE 1: Informally, each tuple in a relation should represent one entity or
relationship instance. (Applies to individual relations and their attributes).

Guideline 2: Try to reduce Redundancy and avoid Update Anomalies

Guideline 3: Avoid too many NULL values
GUIDELINE 4:

- The relations should be designed to satisfy the lossless join condition.

- No spurious tuples should be generated by doing a natural-join of any relations,


----- Page 24 -----
Functional Dependency

*Functional Dependency represents relationship among
attributes.

*Functional dependency says that if two tuples have same
values for attributes A1, A2,..., An, then those two tuples
must and should have same values for attributes B1, B2, ...,
Bn.

*Functional dependency is represented by an arrow sign
(—) that is, XY, where X functionally determines Y. The
left-hand side attributes determine the values of attributes
on the right-hand side.


----- Page 25 -----
QQ) What is Functional Dependency?
Q) How to find the FD from the given table?

() To understand Normalization, first we have to learn

FD.

Q Initially we will take a general example and then

take a actual relation to see what FD is?


----- Page 26 -----
* FD: xLly (x determines y)

«FD means dependency, means some attributes are

dependent on other attributes.

x is called determinant and y is called dependent.


----- Page 27 -----
*Definition of Functional Dependency:

FD:x Oy

If t1.x = t2.x

then t1.y=t2.y

elf it satisfies the above definition, then we can say

x determines y.


----- Page 28 -----
¢ In the above example we just took x and y are one

attribute.
«x and y can be set of attributes.

*There can be one, two, three attributes. These x

and y are set of attributes.


----- Page 29 -----
Functional Dependency

FD:x Oy
If thx=t2x
then tly=t2y

Example __ Student Table

1BM20A1001 Avinash s
1BM20A1002 Balaji A
1BM20A1003 Chandan B
1BM20CS001 Avinash Cc
1BM20CS002 Balaji A

Note that the attribute to the right of

the arrow is functionally dependent
on the attribute in the left of the arrow.

Which Avinash grade ?
Is it 1BM20A1001 or 1BM20CS001

Here USN will help to determine
Grade of the student

USN>Grade | Functional Dependency

A r

7 y

’ \
USN is Grade is
Determinant Dependent
Attribute Attribute


----- Page 30 -----
Functional Dependency

. cai Student Table

1BM20A1001 Avinash s
1BM20A1002 Balaji A
1BM20A1003 Chandan B
1BM20CS001 Avinash c
1BM20CS002 Balaji A

What is the Grade of Avinash ?

Which Avinash grade ?
Is it 1BM20A1001 or 1BM20CS001

Here USN will help to determine
Grade of the student

USNGrade | Functional Dependency

In this table Name alone cannot Determine Grade of the student and also
Name alone does not identify the entire row in the table.
So Name Cannot be PRIMARY KEY.



----- Page 31 -----
Functional Dependency

+ Example Student-Course Table
USN Name Mobile Course | Course | Credits Grade

| -ID -name

/16M14cs001 | Avinash 9449189795 | 10 DBMS 6 s

| 1BM14CS001 | Avinash 9449189795 | 20 Maths 4 A

| 1BM14CS002 | Avinash 8441609444 | 30 Dc 6 A

| 1BM14CS003 | Balaji 7958994491 | 10 DBMS: 6 B

| 1BM14CS003 Balaji 7958994491 | 20 Maths 4 c
What is the Grade of Avinash ? FD:x Oy

If thx =t2x

then tly=t2y


----- Page 32 -----
Functional Dependency

*Example _ Student-Course Table
‘USN Name | Mobile ‘Course | Course | Credits | Grade
5D. -name

TBMI4CSO01 [Avinash [9449169795 [10 [DBMS [6 |S
1eM14CS00i [Avinash | 9449169795 [20 [Maths [4 A
1BM14CS002 [Avinash | eaai609eea [30 [DC [6 A
TBM14CS003 [Balaji [7958994091 [10 [DBMS [6 8
1BM14CS003 | Balaji [7958094491 | 20 ‘Maths = | 4 ig

What is the Grade of Avinash ?

Which USN Avinash Garde and in which Course ? FD:x Oy

If thx=t2.x
then tly=t2y


----- Page 33 -----
Functional Dependency

Student-Course Table

USN Name | Mobile Course | Course | Credits | Grade
ID | -name
1BM14C5001 | Avinash | 9449189795 | 10 Dems |6 is
1BM14C5001 | Avinash | 9449189795 | 20 Maths [4 a
1BM14C5002 | Avinash | 8441609444 | 30 oe (6 a
18M14C5003 _| Balaji 7958994491 | 10 Dems [6 8
1BM14CS003 [Balaji | 7958994491 | 20 Maths (4 fe
What is the Grade of Avinash ? FD:x Oy
Which USN Avinash Grade and in which Course ? If tl.x=t2.x

(USN, Course-ID)

> Grade

(USN,Course-ID) Gra

(1BM14CS001,10) S$
(18M14cS001,20) A

de

then tly =t2y

Here two attributes
(USN,Course-ID) or (USN,Course-Name)
Will determine the Grade


----- Page 34 -----
Functional Dependency

Student-Course Table

USN Name | Mol Course | Course |
<ID__| -name

4BM14CS001 [Avinash | 9449189795 | 10 Dems |

1BM14C5001 [Avinash | 9449189795 | 20 Maths

4BM14CS002 [Avinash | 8441609444 | 30 De

1BM14CS003 | Balaji 7958994491 | 10 Dems

1BM14CS003 [Balaji | 7958994491 | 20 Maths

What is the Mobile number of Avinash ?

Which USN Avinash mobile number ?

USN 3 Mobile

USN 3 Name

FD: x Oy

If t1.x =t2.x

then tly=t2y

USN Mobile

1BM14CS001 9449189795
1BM14CS002 8441609444

USN Mobile

1BM14CS001 Avinash
1BM14CS002_ Avinash



----- Page 35 -----
Functional Dependency

“Example — Student-Course Table
USN Name | Mobile Course | Course | Credits | Grade
“1

TBMI4CS001 [Avinash [9449169795 [10 é A
YBM14CS001 [Avinash | 9449189795 [20 4 A
1BM14CS002 [Avinash | 6441609444 [30 6 A
TBM14CS003 [Balaji | 7988994891 [30 G 8
TBMI4CS003 [Balaji | 7958994491 | 20 4 G

What is the Course-Name whose Credits is 6 ?

FD:x Oy
If thx =t2.x
then tly=t2y


----- Page 36 -----
Functional Dependency

*Example _ Student-Course Table

USN Name | Mobile Course | Course
ID | -name
1BM14C5001 | Avinash | 9449189795 | 10 DBMS
1BM14C5001 | Avinash | 9449189795 | 20 Maths
1BM14C5002 | Avinash | 8441609444 | 30 cd
18M14C5003 _| Balaji 7958994491 | 10 DBMS
[remascsoo3 [Balaji | 7958994491 | 20 Maths

What is the Course-Name whose Credits is 6 ?

CourseID > (Course-Name, Credits)

Course-ID_(Course-Name, Credits)

10 (DBMS,6)
30 (DC,6)



----- Page 37 -----
Functional Dependency

*Example _ Student-Course Table
‘Usn Name Mobile Course | Course | Credits | Grade
5D. -name
TBMI4CSO01 [Avinash [9449169795 [10 [DBMS [6 |S
1eMi4CS001 [Avinash | 9449169795 [20 [Maths [4 [A
1BM14CS002_[Avinash | eaai609eea [30 [Dc [6 [A
YBMI4CS003 [Balaji | 7958098491 10 [DENS [6 [6
1BMI4CS003 [Balaji | 7958998491 [20 [Maths [4 [c
USN > (Name, Mobile)
(USN,Course-ID) > Grade

Course-ID

> (Course-Name, Credits)


----- Page 38 -----
Problem to Solve

relation:

1B bi cl #5
4 b3 C) #6

(a) Given the above extension (state), which of the following dependencies may hold in the
above relation? If the dependency cannot hold, explain why by specifying the tuples that
cause the violation

i. A->B, ii, B>C, ili, C>B,iVB>AV.C>A


----- Page 39 -----
Problem to Solve 10 w

u ba a B
2 b3 a
“1 B bi el 8
+ ASB NO M b3 fe) %6
For A=10, B=b1,b2 Ex: tuple 1,2
+ ASC NO
For A=10, C=c1,c2 Ex: tuple 1,2
+ BOC Yes
For B=b4, C=c1 ; B=b1, C=cl Ex: tuple 3,5 (or Ex: tuple 4,6)
+ C58 NO
For C=C1,, B=b1,b4 Ex: tuple 1,3
+ BGA NO
For B=b3, A=12,14 Ex: tuple 4,6
+ CA NO
For C=c1, A=10,11,13 Ex: tuple 1,3,5
+ ABC YES
+ ACB YES

* BCA NO For (b1,c1)->10 ; (b1,c1) -> 13 Tuple 1,5


----- Page 40 -----
Types of Functional Dependency

1. Trivial Functional Dependency.
2. Non Trivial Functional Dependency.

3. Transitive Functional Dependency.


----- Page 41 -----
1. Trivial Functional Dependency.

FD:X0Y
IfYS Xx

~ ‘hese two are trivial FD
and

XOX

‘An attribute can determine itself Ex: RNOORNO
Ex1: (R.No, Name) |) Name (Here Name is a subset of X)

Trivial FD will always be valid.

Ex2: (R.No, Name) [| R.No (Here R.No is a subset of X)

Trivial FD will always be valid.


----- Page 42 -----
Trivial Functional Dependency
In Trivial Functional Dependency, a dependent is always a
subset of the determinant.
i.e. If X — Y and Y is the subset of X, then it is called trivial

functional dependency


----- Page 43 -----
2. Non-Trivial Functional Dependency.

FD: XUY
XNy =2

0 There is nothing in common between X and Y that is non trivial FD.

* R.No[iName. If you take the intersection of X and Y, nothing is common. This
is non trivial FD.

* It may be or may not be valid.


----- Page 44 -----
Non-trivial Functional Dependency

In Non-trivial functional dependency, the dependent is strictly not

a subset of the determinant.
i.e. If X > Y and Y is not a subset of X, then it is called Non-trivial

functional dependency.


----- Page 45 -----
Non-trivial Functional Dependency

In Non-trivial functional dependency, the dependent is strictly not a
subset of the determinant.
i.e. If X — Y and Y is not a subset of X, then it is called Non-trivial

roll_no name age
42 Ram 17
43 Raju 18
44 Ram 18

Here, roll_no — name is a non-trivial functional dependency, since the
dependent name is not a subset of determinant roll_no

Similarly, {roll_no, name} — age is also a non-trivial functional
dependency, since age is not a subset of {roll_no, name}


----- Page 46 -----
Transitive Functional Dependency

Jn transitive functional dependency, dependent is indirectly dependent on
determinant.

ie. Ifa > b & b > ¢, then according to axiom of transitivity, a > c. This
is a transitive functional dependency


----- Page 47 -----
Transitive Functional Dependency

In transitive functional dependency, dependent is indirectly dependent on
determinant.

ie. Ifa > b & b> ¢, then according to axiom of transitivity, a — . This is
a transitive functional dependency

D name dept ni
42 Ram co 4
43 Raju EC 2
44 Rohan T 1
45 Ram EC 2

Here, ID > dept and dept — building_no,

Hence, according to the axiom of transitivity, ID—> building_no is a valid functional
dependency. This is an indirect functional dependency, hence called Transitive
functional dependency.


----- Page 48 -----
To DO

* Determine all Functional Dependencies in the following table



----- Page 49 -----
To Do

A B Cc D E
1 2 4 6
3 2 5 1 8
1 4 4 5 7
1 2 4 3 6
3 2 5 1 8

Find at least three FDs
which hold on this instance:



----- Page 50 -----
Armstrong’s Axioms / Inference Rules
or
Properties of Functional Dependencies



----- Page 51 -----
Armstrong’s axioms: Functional Dependency

Given that X, Y, and Z are sets of attributes in a relation R, one can derive several properties of
functional dependencies. Among the most important are Armstrong’s axioms, which are used
in database normalization:

1. Subset Property (Axiom of Reflexivity):
If Y is a subset of X, then X-> Y
2. Augmentation (Axiom of Augmentation):
IfX->Y, then XZ-> YZ_Ex: if R.Nol Name then (R.No,Marks) || (Name, Marks)
3. Transitivity (Axiom of Transitivity):
IfX-> Yand Y ->Z, thenX->Z
4. Union: If X -> Y and X -> Z, then X -> YZ (determinants are same and dependents are
different)
5. Decomposition/Splitting: If X -> YZ, then X > Y and X->Z
6. Pseudotransitivity: If (xX -> Y and YZ -> A), then XZ-> A
Ex: If R.No/ Name and Name,Marks| Dept
then (R.No, Marks) |) Dept


----- Page 52 -----
Recall: Functional Dependency

Functional Dependencies provide a formal mechanism to express
Constraints between attributes.

It is a mean of identifying how values of certain attributes are
Determined by values of other attributes.

A functional dependency (FD) generalizes the concept of a key.
Book (acc_no, yr_pub, title)
Acc_no is Primary Key
Formal representation of Constraints
acc_no — yr_pub

acc_no — title


----- Page 53 -----
Normalization

*Normalization is a process of removing redundancy using
functional dependencies.

*To reduce redundancy it is necessary to decompose a
relation into a number of smaller relations.

*There are several normal forms
* First Normal Form (1 NF)
* Second Normal Form (2 NF)
* Third Normal Form (3 NF)
* Boyce-Codd Normal Form (BCNF)
* Fourth Normal Form
+ Fifth Normal Form


----- Page 54 -----
To Understand “First Normal form”

To understand “First Normal Form”, we will look at the definitions of Super key,
Candidate key and Primary key.


----- Page 55 -----
Database Table Keys

*A Key is a single or combination of multiple fields in a table.
*lts is used to fetch or retrieve records/data-rows from data
table according to the condition/requirement.

*Keys are also used to create relationship among different
database tables or views.


----- Page 56 -----
What is Super Key, Candidate Key, Primary Key ?

* Super Key: Super key is a set of one or more than one keys that can be used to
identify a record uniquely in a table.

In super key redundant attributes can exist.

* Candidate Key: A Candidate Key is a set of one or more fields/columns that can
identify a record uniquely in a table. There can be multiple Candidate Keys in one
table. Each Candidate Key can work as Primary Key.

In candidate key no redundant attributes.

* Primary Key: Primary key is a set of one or more fields/columns of a table that
uniquely identify a record in database table. It can not accept null, duplicate
values. Only one Candidate Key can be Primary Key.

Primary key is one of the instance of Candidate Key


----- Page 57 -----
What is Super Key, Candidate Key, Primary Key ?

* Super Key: Super key is a set of one or more than one keys that can be used to identify a record uniquely
ina table.

In super key redundant attributes can exist.

* Candidate Key: A Candidate Key is a set of one or more fields/columns that can identify a record
uniquely in a table. There can be multiple Candidate Keys in one table. Each Candidate Key can work as
Primary Key.

In candidate key no redundant attributes.

* Primary Key: Primary key is a set of one or more fields/columns of a table that uniquely identify a record
in database table. It can not acceptull_ duplicate values. Only one Candidate Key can be Primary Key.

Primary key

Candidate key

Super key


----- Page 58 -----
What is Super Key, Candidate Key, Primary Key ?

*Super Key: Specifies that no two distinct records have the
same value for Super Key.

*Super key may have redundant attributes.



----- Page 59 -----
What is Super Key, Candidate Key, Primary Key ?

*Super Key: Specifies that no two distinct records have the
same value for Super Key.

Super key may have redundant attributes. 5,6, Keys

{BookID}
{BookID, Name}
{BookID, Author}

{Name, Author}
{BookID, Name,Author}



----- Page 60 -----
Super Key

*Super Key: Specifies that no two distinct records have the
same value for Super Key.

*Super key may have redundant attributes. super k
{BookD}

{BookID, Name}
{BookID, Author}
{Name, Author}
{BookID, Name,Author}

{BookID, Name, Author} Name and Author



----- Page 61 -----
Candidate Key

*Candidate Key is a super key without redundancy
*Not reducible

*More than one possible candidate keys

Candidate Keys

{BookID}
{Name, Author}



----- Page 62 -----
Primary Key

*Primary is one of the instance of Candidate Key.

*Primary key chosen by Database designer, which will not
have null values

Primary Key
{BookID}



----- Page 63 -----
Relation between Super, Candidate and Primary key

[eet] Wome | Avtor

xz

Super Keys

{BookiD}
{BookID, Name}

{BookID, Author}
{Name, Author}
{BookID, Name,Author}

Candidate Keys
> Primary key

Candidate key

> sumanier Primary Key



----- Page 64 -----
Summarizing

*Candidate Key: are individual columns in a table
that qualifies for uniqueness of each row.

*Primary Key: is the column you choose to maintain
uniqueness in a table at row level.

*Super Key: If you add any other Column to a
Primary Key then it become a Super Key


----- Page 65 -----
We will next learn

How to find super keys and candidate keys from the given functional
dependencies

For this we have to understand Closure of Attributes


----- Page 66 -----
Finding Closure of Attributes

*The set of attributes that are functionally dependent on the attribute A is
called Attribute Closure of A and it can be represented as A*.

*Closure tells us which all attributes in the relation can be determined by an
attribute or a set of attributes.

*Super key: An attribute/set of attributes that determines all the other
attributes in that relation.

* Candidate key: An attribute/set of attributes whose proper subset should not

contain the super key. It is also called minimal super key.


----- Page 67 -----
Example

Given R(E-ID, E-NAME, E-CITY, E-STATE)
FDs = { E-ID->E-NAME,

ED->E-CITY,

ED->E-STATE,

E-CITY->E-STATE }


----- Page 68 -----
Example

Given R(E-ID, E-NAME, E-CITY, E-STATE)
FDs = { E-ID->E-NAME,

EXD->E-CITY,

EXD->E-STATE,

E-CITY->E-STATE }

The attribute closure of E-ID can be calculated as:
* Add E-ID to the set {E-ID}

* Add Attributes which can be derived from any attribute of set. In this case, E-NAME and
E-CITY, E-STATE can be derived from E-ID. So these are also a part of closure.

* As there is one other attribute remaining in relation to be derived from E-ID. So result is:
+ (E-ID)* = {E-ID, E-NAME, E-CITY, E-STATE }

+ (E-NAME)* = {E-NAME}

+ (E-CITY)* = {E-CITY, E_STATE}


----- Page 69 -----
Question

Find the attribute closures of B,
given FDs R(ABCDE) = {AB->C, B->D, C->E, D->A}
To find (8)°,we will add attribute in set using various FD which has been shown in table below.

Attributes Added in

eats FD used
8) Triviality
{B.D} BoD
{B.D,A} D>A
{B.D,A,C} ABC
- BDACES Cre E using(©>€) and then A using (->A) and set

becomes. (C0)"=(,0,6,AF

+ Similarly we an find (8) by adding 8 and cinta the st (eval) and then D using (8-0) and then E using (CE) and then A
SSB ae Oe epee eAy (eatin) (620) B(ce)


----- Page 70 -----
Finding Closure of Attributes

* Consider following functional dependencies
Closure of Attribute A is written as
Closure of attribute is set

Of attributes which can be
determined by A

Closure of A* is {A,B,D}


----- Page 71 -----
Finding Closure of Attributes

Closure of Attribute A is written as

Consider following functional dependencies At

Closure of attribute is set
Of attributes which can be
determined by A

Closure of A’ is {A,B,D}

What is closure of B and C ?


----- Page 72 -----
Question

Consider the relation scheme R(E, F, G, H, |, J, K, L, M, N) and the set of functional
dependencies-

{E,F}>{G}
{F}> {I,J}
{E,H}>{K,L}
{K}>{M}
{L}>{N}

What is the candidate key for R?
{E,F}

{EB H}

{E,F,H,K,L}

{E}


----- Page 73 -----
Answer

Consider the relation scheme R(E, F, G, H, |, J, K, L, M, N) and the set of functional
dependencies-

{E,F}>{G}
{F}> {I,J}
{E,H}>{K,L}
{K}>{M}
{L}>{N}

What is the candidate key for R?
{E,F}

{E,F,H}

{E,F,H,K,L}

{E}


----- Page 74 -----
Question

Find out how candidate keys the following relation has



----- Page 75 -----
Answer

Find out how candidate keys the following relation has

Totaly four candidate keys ={DA, DB, DE, DF}


----- Page 76 -----
Problem to Solve

Given relation R(A,B,C,D,E)

with dependencies

AB ->C

CD->E

DE->B

Is AB a candidate key of this relation?
If not, is ABD? Explain your answer.


----- Page 77 -----
Problem to Solve

Given relation R(A,B,C,D,E)

with dependencies AB -> C CD -> E DE ->B
is AB a candidate key of this relation?

If not, is ABD? Explain your answer.

Answers:
Closure of AB+ = {A,B,C}
NO, AB is NOT KEY

Because AB cannot determine all attributes, Closure of AB+ is {A,B,C}
which is proper subset of {A,B,C,D,E}


----- Page 78 -----
Problem to Solve

Gen elation RUA...) with dependences AB-> CCD», DE->B

le AB candidate key of tisreltion? if nt, ABD? Explain your answer,

Answers: es, ADF =(A.8,C.0,E}. Yes, ABDIS a canada ey. No subset of ts
atuibutes sa key


----- Page 79 -----
Finding Candidate Keys

Solve the given problems to identify candidate key

1. RIA,B,C,D,E,F.G}
FD’s AB->F , AD-> E, F->G

Answer: One possible CK is {ABCD}

2. R{F,O,R,UM}
FD's FO->U , ORU->M

Answer: One possible CK is {FOR}



----- Page 80 -----
Trivial Functional Dependency

IfY C X, Yis subset of X
then we have trivial functional dependency
X->Y

Example:
{BC} C {ABC} So the trivial functional dependency ABC ->BC
YCX X ->Y


----- Page 81 -----
Trivial Functional Dependency

Some functional dependencies are said to be trivial because they are satisfied by all relations.
Functional dependency of the form A->B is trivial if B C A or A trivial Functional
Dependency is the one where RHS is a subset of LHS.

Example,

A->A\is satisfied by all relations involving attribute A.
SSN-->SSN

PNUMBER-->PNUMBER

SSN PNUMBER ~>PNUMBER

SSN PNUMBER ~> SSN PNUMBER


----- Page 82 -----
Non Trivial Functional Dependency

Ifa functional dependency X->Y holds true where Y is not a subset of X then this dependency
is called non trivial Functional dependency.

* For example:
An employee table with three attributes: emp_id, emp_name, emp_address.
The following functional dependencies are non-trivial:
emp_id-> emp_name (emp_name is not a subset of emp_id)

‘emp_id-> emp_address (emp_address is not a subset of emp_id)

* On the other hand, the following dependencies are trivial:
{emp_id, emp_name}-> emp_name [emp_name is a subset of (emp_id,

emp_name]}

Completely non trivial FD:
Ifa FD X->Y holds true where X intersection Y is null then this dependency is said to be
completely non trivial function dependency.

Example: SSN —> Ename, PNUMBER --> PNAME, PNUMBER—> BDATE


----- Page 83 -----
Various Database table Normal Forms

* First Normal Form (1 NF)
*Second Normal Form (2 NF)
*Third Normal Form (3 NF)
*Boyce-Codd Normal Form (BCNF)


----- Page 84 -----
Practical Use of Normal Forms

* Normalization is carried out in practice so that the resulting designs are
of high quality and meet the desirable properties
*The practical utility of these normal forms becomes questionable when

the constraints on which they are based are hard to understand or to
detect

*The database designers need not normalize to the highest possible
normal form. (usually up to 3NF, BCNF or 4NF)

* Denormalization: the process of storing the join of higher normal form
relations as a base relation—which is in a lower normal form


----- Page 85 -----
First Normal Form (1 NF)

A database table is said to be in 1 NF if

* Values of each attribute is atomic. An atomic value is a value that cannot be
divided

* All entries in any column must be of the same kind

+ Each column must have a unique name

* No two rows are identical

1NF: Disallows composite attributes, multivalued attributes, and
nested relations; attributes whose values for an individual record
are non-atomic.


----- Page 86 -----
First Normal Form (1 NF)

A database table is said to be in 1. NF if

+ Values of each attribute is atomic. An atomic value is a value that cannot be divided.
+ All entries in any column must be of the same kind

+ Each column must have a unique name

Whether this table is in
First Normal form ?



----- Page 87 -----
First Normal Form (1 NF)

A database table is said to be in 1 NF if
+ Values of each attribute is atomic. An atomic value is a value that cannot be divided.
+ All entries in any column must be of the same kind

+ Each column must have a unique name
+ No two rows are identical

Not atomic values

Whether this table is in
First Normal form ?



----- Page 88 -----
First Normal Form (1 NF)

‘A database table is said to be in 1 NF if

+ Values of each attribute is atomic. An atomic value is
+ All entries in any column must be of the same kind

+ Each column must have a unique name wi Bai DBMS
+ No two rows are identical 101 Asif cn
101 Asif oy
STUDENT
101 Asif SE
102 Amit co

DBMS, CN 1NF

OD, S€ | pe | 102 ‘Amit 05

103 Arpt oy
co. oS
103 Arpt DS
COD ,0S,¢cN 103 ‘Arpit cN
4) s

103 Arpit DEMS:



----- Page 89 -----
First Normal Form (1 NF)

‘A database table is said to be in 1 NF if

+ Values of each attribute is atomic. An atomic value is a value that cannot be divided.

* All entries in any column must be of

the same kind

+ Each column must have a unique name
+ No two rows are identical

Convert following table to 1 NF

TABLE PRODUCT

Product ID Color Price
1 red, green 1699
2 yelow 799
3 green 1750
4 yellow, blue | 9.99
6 red 2.99

1NF


----- Page 90 -----
First Normal Form (1 NF)

‘A database table is said to be in 1 NF if

+ Values of each attribute is atomic. An atomic value is a value that cannot be divided.

+ Allentries in any column must be of

the same kind ,
Solution 1

+ Each column must have a unique name

Convert following table to 1 NF

TABLE_PRODUCT 1 red 15.99
Product ID Color Price 1NF : Gea ee
1 ved, green | 1500 | Em | 2 yellow Be
2 yelow 2399 3 Ges 17.50
3 green 17.50 a yellow 9.99
4 yellow, blue | 9.99 4 blue 9.99
5 red 29.99 5 red 29.99



----- Page 91 -----
First Normal Form (1 NF)

‘A database table is said to be in 1 NF if

+ Values of each attribute is atomic. An atomic value is a value that cannot be divided.
+ All entries in any column must be of the same kind

+ Each column must have a unique name

*+ No two rows are identical

Convert following table to
TABLE_PRODUCT

1NF

Producti Calor Price
1 ved, green | 15.99
2 yellow 23.8
3 aren 17.50
4 yeliow, blue | 9.99
5 red 2989

1NF

=)

Given ProductID is Primary Key
Solution 2

TABLE_PRODUCT PRICE

TABLE_PRODUCT_COLOR

ProauetiD | prise Produc
1 1598
2 7398
a 1780
a 389
3 7998



----- Page 92 -----
Example: Normalization into 1NF

NF: is independent of Primary Key
Disallows composite attributes, multivalued attributes,
and nested relations; attributes whose values for an

individual tuple are non-atomic

‘NF: Removes repeating groups

Table Department with
Attributes DNAME, DNUMBER, DLOCATIONS
Primary Key DNUMBER

Functional Dependency DNUMBER -> (DNAME,DMGRSSN, DLOCATIONS)

DEPARTMENT

| NAME NUMBER OMGRSSN | LOCATIONS:

t | }



----- Page 93 -----
Example: Normalization into 1NF

NF: is independent of Primary Key
Disallows composite attributes, multivalued attributes,
and nested relations; attributes whose values for an

individual tuple are non-atomic

‘NF: Removes repeating groups

Table Department with

Attributes DNAME, DNUMBER, DLOCATIONS.

Primary Key DNUMBER

Functional Dependency DNUMBER -> (DNAME,DMGRSSN, DLOCATIONS)

DEPARTMENT

NAME NUMBER OMGRSSN LOCATIONS.

t t }

Not atomic values
DEPARTMENT

DNAME OMGRSSN DLOCATIONS Not in 1NF

Research 5 993445555 Bellaire, Sugartand, Houston}
Admingvaton 4 97654321 (Sater
Headquaners 1 8665685 (Houston)



----- Page 94 -----
Exam

nple: Normalization into 1NF

Approach
oePeRTVenT
[owe [pues [oom 7
rete s sess dae Sogn Hos)
Adm ristraion 4 987654321 {Stztforo]
‘Headquarters 1 ‘BEBBESSSS: {Hous:on),
Conversion to 1NF
DEPARTMENT
DNAME DNUMBER DMGRSSN DLOCATION.
Research 5 333445555 Bellaire
Research 5 333445555 ‘Sugarland
Research 5 333445555 Houston
Administration 4 987654321 ‘Stafford
Headquarters 1 888665555 Houston

Disadvantage: Introducing redundancy in the table.


----- Page 95 -----
aporeXemple: Normalization into 1NF

[Cowwe | ~oanecn | owonssv SLconoNS
=. : ees a

Conversion to INF

If given DNUMBER is primary Key

Research 5

333445555

owes lames fev

Bellaire

Sugarland

‘Administration

987654321

Houston

Headquarters

888665555

Stafford

Houston.

‘Advantage: This approach does not

suffer from redundancy.

Propagating
Primary
Key


----- Page 96 -----
Example: Normalization into 1NF

Approach 3
DEPARTMENT
wave | owwwoen | oMGASSN LOCATIONS
Reson 5 45555 (Bete, Spat Houson)
emsraton 4 eTeSA21 (Suter)
Heasgearers 1 568665555 (Houston)
Conversion to INF If given that at most maximum

Three department locations can exist

Research 5 333445555 | Bellaire Sugarland Houston
Administration — | 4 987654321 _| Stafford
Headquarters 1 888665555 | Houston

Disadvantage: This approach introduces NULL values for
most departments having fewer than three locations.


----- Page 97 -----
We will next learn Second Normal Form

For this we have to understand
Prime and non-prime attribute

Transitive Functional Dependency

Fully functional dependent attribute
Partial functional dependent attribute


----- Page 98 -----
Prime And Non-prime attribute

*Prime attribute: Attribute present in candidate key
*Non-prime attribute: Attribute not present in candidate key

Prime attribute
If attribute is a part of candidate key then
it will be prime attribute

Non-prime attribute,
An attribute which is never included in any candidate key.


----- Page 99 -----
Identify prime and non-prime attribute for given functional
dependencies

First find Candidate Key
Candidate Key is {CE}

So
Prime attributes are {C, E}

Non-Prime attributes are {A,B,D,F}



----- Page 100 -----
Transitive Functional Dependency

X>yY
=» X > Z__ X transitively determines Z
Y>Z



----- Page 101 -----
Fully Functional Dependent Attribute
X>yY

Y is fully functional dependent on X
Only if Y cannot determined by any proper subset of X, i.e.,
removal of any attribute A from X means that the dependency does not hold


----- Page 102 -----
Fully Functional Dependent Attribute
X>yY

Y is fully functional dependent on X
Only if Y cannot determined by any proper subset of X, i.e.,
removal of any attribute A from X means that the dependency does not hold

Example
We say for the Functional Dependency ABC _ D,
Dis fully functional dependent on ABC

Only if we do not have the FD’s
{A D,

BLD,

cD,

ABD

BCD,

ACD}



----- Page 103 -----
Partial Functional Dependent Attribute

X »y Yis partially functional dependent on X
Only if Y can be determined by any proper subset of X

Note: A functional dependency X -> Y is partial dependency if some
attribute A € X can be removed from X and the dependency still holds;
that is, for some A € X,(X-{A})-> Y holds


----- Page 104 -----
Partial Functional Dependent Attribute

X > Y_ Yispartially functional dependent on X
Only if Y can be determined by any proper subset of X

Example
We say for the Functional Dependency AC _ P,
P attribute is partially functional dependent on AC

Only if we have the FD’s
fA” P}

or

{CP}



----- Page 105 -----
Normal Forms Based on a Primary Key

1 NF: is independent of Primary Key
Disallows composite attributes, multivalued attributes, and nested
relations; attributes whose values for an individual tuple are
non-atomic

2.NF: A relation schema R is in second normal form (2NF) if it is in 1 NF and if every
non-prime attribute A in Ris fully functionally dependent on the primary key


----- Page 106 -----
‘Smith, John B.



----- Page 107 -----
emp_pRos

723456789



----- Page 108 -----
Example: Normalizing to 2 NF based on Primary Key
2 NF: A relation schema R is in second normal form (2NF)
ifitisin 1 NF
and
if every non-prime attribute A in R is fully functionally dependent
on the primary key

2NF: Removes Partial dependencies

Note: For tables where primary key contains multiple attributes, no
Non-key attribute should be functionally dependent on a part of
primary key.


----- Page 109 -----
Example: Normalizing to 2 NF based on Primary Key

2.NF: A relation schema R is in second normal form (2NF)
ifitisin 1 NF

and

if every non-prime attribute A in R is fully functionally dependent
on the primary key

Question: Is the following table EMP_PROJ satisfies 2 NF

Given

Primary key (Ssn, Phumber)

FD's

FD 1: (Ssn,Pnumber) ->Hours

FD 2: (Ssn) -> Ename

FD 3: (Pnumber) -> (Pname,Plocation)



----- Page 110 -----
Example: Normalizing to 2 NF based on Primary Key
2 NF: A relation schema Ris in second normal form (2NF) ifit isin
NF and if every non-prime attribute A in Ris fully functionally dependent on the primary key
Examples of FULL and PARTIAL

{SSN, PNUMBER} -> HOURS is a full FD since neither
SSN -> HOURS nor PNUMBER -> HOURS holds

{SSN, PNUMBER} -> ENAME is not a full FD, itis called a partial dependency
because SSN -> ENAME also holds

EMP_PROJ Given

Primary key (Ssn, Pnumber)

FD's
FI 1 1
1 t FD 1: (Ssn,Pnumber) >Hours
Fo FD 2: Ssn) > Ename

im | FD 3: (Pnumber) -> (Pname,Plocation)

Relation EMP_PROJ(Ssn,PrumberHours Ename,Pname,Plocation) is not in 2 NF
Because in FD 2: (Ssn) -> Ename, Ssn alone can determine Ename

Ssn is part of primary key (Ssn,Paumber) i.e Ssn_ proper subset of (Ssn,Ename)
Similarly in FD 3 : (Prumber) -> (Prame,Plocation}, Phumber is part of primary key (Ssn,Ename)


----- Page 111 -----
Example: Normalizing to 2 NF based on Primary Key

2 NF: A relation schema Ris in second normal form (2NF) if itis in

{NF and if every non-prime attribute A in R is fully functionally dependent on the primary key

EMP_PROJ
[[Ssn [Pnumber [Hours [Ename [Pname | Piocation |

FOI 4
FD2

FDS

2NF Normalization

EPI EPS

([Sso [Poumber | Hours aa [_Poumber

FD1| | 4 FD2| 4 FD3|



----- Page 112 -----
Example: Normalizing to 2 NF based on Primary Key

2 NF: A relation schema R is in second normal form (2NF) if it is in
‘NF and if every non-prime attribute A in R is fully functionally dependent on the primary key

EMP_PROJ
$sn_[Poumber | Hours | Ename | Pname | Procation

Fos
Ifa table is not in 2 NF, it can be normalized to 2 NF

‘2NF Normalization By breaking into number of 2 NF tables in which nonprime
attributes are associated only with part of primary key
‘On which they are fully dependent.

EPI EP2 EPS

‘Ssn | Poumber_| Hours Ssn_|Ename Poumber | Pname | Plocation
FO1| 4 Foot FO3| 4 4
Note:

English words meaning Table or Relation are one and the same wart. database


----- Page 113 -----
Question

Consider a relation- R(V,W, X,Y, Z) with functional
dependencies-

VW > XY

YoV

WX > YZ

The possible candidate keys for this relation are: {VW , WX , WY}
Is this relation in Second Normal Form (2NF) ?


----- Page 114 -----
Answer

Consider a relation- R(V,W, X,Y, Z) with functional dependencies-
VW ~ XY

YoV

WX = YZ

The possible candidate keys for this relation are: {VW , WX , WY}

Is this relation in Second Normal Form (2NF) ?

Prime attributes ={V,W,X,Y}
Non-prime attributes = { Z }
Now, if we observe the given dependencies-

There is no partial dependency. This is because there exists no dependency
where incomplete candidate key determines any non-prime attribute.

Thus, we conclude that the given relation is in 2NF.


----- Page 115 -----
Question

Take a look at these functional dependencies in the relation

R (M,N, 0, P)

Here, FD’s are

MN ->O

NO->P

In the relation mentioned above, MN serves as the only candidate
ey.

Is this relation in 2NF ?

Also, no partial dependency exists here. It means that the proper
subsets of MN do not determine non-prime attributes.


----- Page 116 -----
Answer

Take a look at these functional dependencies in the relation

R (M,N, 0, P)

Here, FD’s are

MN ->O

NO->P

In the relation mentioned above, MN serves as the only candidate
ey.

Also, no partial dependency exists here. It means that the proper

subsets of MN do not determine non-prime attributes.


----- Page 117 -----
Example: Normalizing to 2 NF based on Primary Key
2 NF: A relation schema R is in second normal form (2NF)
ifitisin 1 NF
and
if every non-prime attribute A in R is fully functionally dependent
on the primary key

2NF: Removes Partial dependencies

Note: For tables where primary key contains multiple attributes, no
Non-key attribute should be functionally dependent on a part of
primary key.


----- Page 118 -----
Rough Slide: Example to illustrate Why we should Normalize
table to second Normal form

R(ABCD)
Key: AB
FDL: AB>C
FD2:B->C

Prime Attributes: {A,B} Non-Prime Attributes: {CD}

j> Asand A and Bare combinable the key,
Hence A or B can take Null value.
Nall 2 ry 2 But not both A and B can take Null value.

10 B If Bis allowed to take Null value then
how it can determine C



----- Page 119 -----
Normalizing to 3 NF based on Primary Key

3 NF: A relation schema R is in third normal form (3NF)

if it is in 2NF

and

no non-prime attribute A in R is transitively dependent on

the primary key. | 3'VF: Removes transitive dependencies



----- Page 120 -----
Rough Slide: Example to illustrate Why we should Normalize table to Third

R(ABC)
Ais the Key
FD1:A->B

FD2:B->C Ifwe do not
Reduce to 3NF
Then table will have
redundant data


----- Page 121 -----
Normalizing to 3 NF based on Primary Key

3 NF: A relation schema R is in third normal form (3NF)

if itis in 2NF

and

no non-prime attribute A in R is transitively dependent on

the primary key.
Question: In the following table EMP_DEPT , what is the transitive

dependency that exist on primary key

ENP DEPT

thane i] le | es Dnt | Dane | Dns Given
Primary key {Ssn}
\ \ \ | | FD 1: Ssn -> {Ename,Bdate,Address, Dnumber}

FOL FD 2: Dnumber -> {Dname,Dmgr_ssn}

FD2


----- Page 122 -----
Normalizing to 3 NF based on Primary Key

3 NF: Arelation schema R is in third normal form (3NF)
ifitisin 2NF

ond

no non-prime attribute A in R is transitively dependent on.

the primary key. Question: Is the following table EMP_DEPT satisfies 3 NF

eup_pepr Given
Ename_| San | Bante | Adsiess | Cramber [ Drane | Dmeraen ] Primary key {Ssn}
4 yt + t FD 1: Ssn-> (Ename,Bdate Address, Dnumber}
FD 2: Dnumber -> {Oname,Dmgr_ssn}

* SSN -> DMGRSSN is a transitive FD
+ Since SSN -> DNUMBER and DNUMBER -> DMGRSSN hold
* SSN -> ENAME is non-transitive
+ Since there is no set of attributes X where SSN -> X and X -> ENAME



----- Page 123 -----
Example: Normalizing to 3 NF based on Primary Key

Given
Primary key {Ssn}

FD 1:Ssn > (Ename,Bdate Address, Daumber}
FD 2: Dnumber > {Dname,Dmgr_ssn}

EMP_DEPT
Ename | Ssn | Bdate | Address | Dnumber | Dname | Dmgr_ssn
4 | $ 4+ +4 4 f
FDL Fo2

J Converting to 3 NF

£02

Bie | Mes | Onn | [Du



----- Page 124 -----
Until now What we have learned

First Normal Form.
Second and Third Normal form based on PRIMARY KEY.

Next we will learn Second and Third Normal form based on ALL CANDIDATE KEYS in a given
relation.


----- Page 125 -----
General definition of Second Normal Form

* General definitions of 2NF take into account relations with multiple candidate
keys

2.NF: A relation schema R is in second normal form (2NF)

if every non-prime attribute A in R is fully functionally dependent on every key of
R


----- Page 126 -----
Example: Normalizing into 2 NF

2.NF: A relation schema R is in second normal form (2NF)
if every non-prime attribute A in R is fully functionally dependent
on every key of R

Candidate Key

Given
LoTs Primary Key {Property_id#}
[Property id [County.name | Lot# | Avea | Price | Tax rate Candidate key {County_name,Lot#}
mf | jet |
F038 {
FO4 {

Question
Which attributes are prime, which are nonprime?
Are any nonprime attributes partially dependent on prime attributes?



----- Page 127 -----
Example: Normalizing into 2 NF

2.NF: Arelation schema Ris in second normal form (2NF)
if every non-prime attribute A in R is fully functionally dependent
on every key of R

Candidate Key

tors ro Given
Primary Key {Property_id#}
Cosy vane [tat [he [Price [Tac
(Reveae, I ttt “t Candidate key {County_name,Lot#}
cl a
Foe Lt
roe L4
J Converting to 2 NF
Lorst LoTs2

[Propery.id@ [County name T tote | Area | Price ] same | Tax rate
FOI | } 4 4 } FDS }
roo l tt

FD4 4



----- Page 128 -----
General definition of Third Normal Form

* General definition of 3 NF take into account relations with multiple candidate
keys

3 NF: A relation schema R is in 3 NF if every nonprime attribute of R meets both of
the following conditions:

(a) It is fully functionally dependent on every key of R
(b) It is non-transitively dependent on every key of R

Note: There should not be any Transitive Functional Dependency, ie, there should not be any functional
dependencies like a non-key (non-prime) attribute depends on another non-key (non-prime) attributes.
Simply, we need all the non-key attributes must depend on the key only


----- Page 129 -----
General definition of Third Normal Form

* General definition of 3 NF take into account relations with multiple candidate keys.

3 NF: A relation schema R is in 3 NF if every nonprime attribute of R meets both of the
following conditions:

(a) Itis fully functionally dependent on every key of R
(b) It is non-transitively dependent on every key of R

Note: There should not be any Transitive Functional Dependency, ie., there should not be any functional
dependencies like a non-key (non-prime) attribute depends on another non-key (non-prime) attributes. Simply, we
need all the non-key attributes must depend on the key only

Example: R(A,B, C, D, E). Consider candidate keys as {A}, {BC} with FD’s {A->BCDE, BC->ADE, D->E}
Then Non-prime attributes are {0,£). The functional dependency
{D->E} violates the condition of 3NF because D and E are non-prime attributes


----- Page 130 -----
Example: Normalizing into 3 NF
3 NF: A relation schema R is in 3 NF if every nonprime attribute of R
meets both of the following conditions:
{a) Its fully functionally dependent on every key of R
{b) It is non-transitively dependent on every key of R

Note: There should not be any Transitive Functional Dependency, ie, there
should not be any functional dependencies like a non-key (non-prime) attribute
depends on another non-key (non-prime) attributes. Simply, we need all the
non-key attributes must depend on the key only

Lors:
[Property ide | County_name | Lot# | Area | Price

ot r r a Given
a a a Primary Key {Property_id#}

soo $ | | Ff Candidate key {County_name,Lotit}
FD4 | 4
Question

Are any nonprime attribute dependent on nonprime attribute?


----- Page 131 -----
Example: Normalizing into 3 NF
3 NF: A relation schema R is in 3 NF if every nonprime attribute of R
meets both of the following conditions:
(a) It is fully functionally dependent on every key of R
(b) It is non-transitively dependent on every key of R

Note: There should not be any Transitive Functional Dependency, i., there
should not be any functional dependencies like a non-key (non-prime) attribute
depends on another non-key (non-prime) attributes. Simply, we need all the
non-key attributes must depend on the key only

Lorst
[Propery.ia® [County name | Lot# [Area | Price

For i ar Given

Primary Key {Property_idi}

roe | + 4
! Candidate key {County_name,Lot#}

J Converting to 3 NF

LOTSIA LOTS1B
Property.id# [ County name | Lot# | Area Area | Price
FOI 4 4 } Fo4 4
mat =| | f



----- Page 132 -----
Summarizing 1NF, 2NF, 3 NF

INF: Removes
repeating groups

1NF

Column values should atomic

2NF: Removes
Partial dependenci

3NF: Removes
transitive dependencies

2NF

Non-Prime attribt
Fully Dependent
candidate key

utes should be
on each

3NF
Non-Prime attribt

utes should not

Determined by a non-prime

attribute

First Restriction

Second Restriction

Third Restriction


----- Page 133 -----
Summarizing 1NF, 2NF, 3 NF

1NF: No Multivalued attributes or All columns should be atomic

2NF: It should be in 1 NF and All non-prime attributes should be fully
functionally dependent on primary key or each candidate key

3NF:
For relation R to be in 3 NF check
(a) R should be in 2 NF

(b) No non-prime attribute should be transitively dependent on Candidate
key or There should not be the case that a non-prime attribute is
determined by another non-prime attribute.


----- Page 134 -----
Problem to Solve: Normalizing to 2 NF and 3 NF

Consider the relation R = {A, B, C, D, E, F, G, H, |,
functional dependencies FD1 {A, B} > {C}

- FD2 {A} — {D, E}
F={{A, 8) (C, oan an

{A} — {D, E}, FD4 {F}— {G, H}
{B} > {F}, FDS {D}— {i,J}
{F} — {G, H},

{0} (1, JH.

Given the Key of R as {AB}
(a) | Decompose R into 2NF.
(b) | Decompose R into 3NF.


----- Page 135 -----
Problem to Solve: Normalizing to 2 NF and 3 NF

Consider the relation R = {A, B, C, D, E, F, G, H, |, J} and the set of
functional dependencies F = {{A, B} — {C}, {A} — {D, E}, {B} — {F}, {F} >
{G, H}, {D} — {I, J}}. Given the Key of R as {AB}

(a) | Decompose R into 2NF.
(b) | Decompose R into 3NF.

Splitting out attributes based on relations only partially dependent on the key gives
{A,D,E,1,J} preserves the functional dependencies

{{A} — {D, E},{D} — {.J}}
preserves {{B} — (F}, ee a)
preserves {{A, B} — {C}}

's of these subrelations are underlined,

Decompose R into 2NF

five dependencies on their keys gives

Decompose R into 3NF



----- Page 136 -----
Problem to Solve: Normalizing to 2 NF and 3 NF

Consider the relation R = {A, B, C, D, E, F, G, H, I, J} and the set of functional
dependencies

F={{A, B} > {C},
{A} > {D, E},
{8}— {F},

{F} > {G, H},

R(A,B,C,D,E,F,G,H,1,J)

A|B c D 3 FG H I a

Fo1|

FD2|
FD3

FD4

FDS



----- Page 137 -----
Problem to Solve: Normalizing to 2 NF and 3 NF

[ale TeTe Tel eisai []
ro
FDS ED

R1(A,B,C) R3(B,F,G,H)
A |B A 27] [B[Fl[e6 [TH]
FD2 FD3

FD4



----- Page 138 -----
Problem to Solve: Normalizing to 2 NF and 3 NF

Consider the relation | R(A,B,C,D,E,F,G,H,1,) nncies F = ({8, B} —» (Ch, {4} =» {0, €}, (8)
HF (EG, HY AC F. (b) Decompose R into 3NF.
Blclole| Fl[s|ali]3

iL
roa

ros| ml

AB Converting to 2.NF

RUAB.C) RaBEGH
[alete a pBlFel[so/u
Fo4 T
ros
to3 NF
R1(A,B,C) R2a(A,D,E) R2b(D,1,J) R3a(B,F) R3b(F,G,H)
Alp |c|[alo[e][o[1]3][elr
FD1 FD 2| l Tos FD3 FD4



----- Page 139 -----
Problem to Solve: Normalizing to 2 NF and 3 NF

Consider the relation R = {A, B,C, D, E,F, G, H, |, J} and the set of functional dependencies
F={{A, B}— {C},
{B,D} — {E, F},
{A,D} — {G,H},
{A} — {I},
{H} > 0},
Given the Key of R as {ABD}
(a) Decompose R into 2NF.
(b) Decompose R into 3NF.


----- Page 140 -----
Problem to Solve

Consider a dependency diagram of relation R and normalize it up to third normal
form.

a arts peaesyoas

—

Picj-no [n-ne Emp Emp_neene}Jeb_class|chq-hy,
a a a SO



----- Page 141 -----
Problem to Solve

Consider a relation with schema R(A, B, C, D)

and

FD = {AB —>C,
CD,
DA}

(a)What are all the non-trivial FDs that follow from the given FD’s?
(b) What are all the candidate keys of R?

(c) What are all the superkeys of R that are not candidate keys?


----- Page 142 -----
Non Trivial Functional Dependency

Ifa functional dependency X->Y holds true where Y is not a subset of X then this dependency
is called non trivial Functional dependency.

* For example:
An employee table with three attributes: emp_id, emp_name, emp_address.
The following functional dependencies are non-trivial:
emp_id-> emp_name (emp_name is not a subset of emp_id)

‘emp_id-> emp_address (emp_address is not a subset of emp_id)

* On the other hand, the following dependencies are trivial:
{emp_id, emp_name}-> emp_name [emp_name is a subset of (emp_id,

emp_name]}

Completely non trivial FD:
Ifa FD X->Y holds true where X intersection ¥ is null then this dependency is said to be
completely non trivial function dependency.

Example: SSN —> Ename, PNUMBER --> PNAME, PNUMBER—> BDATE


----- Page 143 -----
Answers

Consider a relation with schema R(A, 8, C, D) and FD = {AB — C, C+ D, D+ A}
Single Attributes:

AtSA

We need to compute the cle B+ =B
‘C+= ACD (New dependency: C—+ A)
D+=AD

(a) What are all the non-triv

Pairs of Attributes:
AB#+= ABCD (New dependency: AB —» D)

‘AC+= ACD. (New dependency: AC + D)

‘AD+= AD

BC+= ABCD (New dependencies: BC + A and BC-+D)
BD+= ABCD (New dependencies: BD + A and BD-+C)
(CD+= ACD (New dependencies: CD —+ A)

‘Triples of Attributes:
ABC+ = ABCD (New dependencies: ABC — D)
‘ACD+= ACD

BCD+ = ABCD (New dependencies: BCD —+ A)
ABD+ = ABCD (New dependencies: ABD + C)

So, we get a total of 11 non-trivial FDs.


----- Page 144 -----
Answers

(b) What are all the candidate keys of R?

From the closures above, we find that AB, BC, and BD are keys, because
they have ABCD as the closure, and they are minimal.

(c) What are all the superkeys of R that are not candidate keys?

The superkeys are all those that contain one of those three candidate keys.
Thus, the superkeys are ABC, ABD, BCD, and ABCD.


----- Page 145 -----
Various Database table Normal Forms

*Boyce-Codd Normal Form (BCNF)


----- Page 146 -----
Summarizing 1NF, 2NF, 3 NF

INF: Removes
repeating groups

1NF

Column values should atomic

2NF: Removes
Partial dependenci

3NF: Removes
transitive dependencies

2NF

Non-Prime attribt
Fully Dependent
candidate key

utes should be
on each

3NF
Non-Prime attribt

utes should not

Determined by a non-prime

attribute

First Restriction

Second Restriction

Third Restriction
